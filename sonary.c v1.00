#include <avr/io.h>
#include "sonary.h"
#define F_CPU 8000000
#include <util/delay.h>
#include <avr/interrupt.h>

#define CYFRA1 PC2
#define CYFRA2 PC1
#define CYFRA3 PC3
#define CYFRA4 PC4

#define TRIGGER1 PD6
#define TRIGGER2 PD5

#define czas_odswierzania 15

void wyswietlanie1 (volatile uint8_t *wskaznik)
{
    int czas, jednostki, dziesiatki;
    int liczby[10] = {0x14, 0xD7, 0x8C, 0x85, 0x47, 0x25, 0x24, 0x97, 0x4, 0x5};
    jednostki=(*wskaznik%10); //obliczanie cyfry jednostki
    dziesiatki=(*wskaznik/10); //oblicznie cyfry dziesiatek
    for(czas=0; czas<czas_odswierzania; czas++)
    {
        PORTC = _BV(CYFRA1);  //zaslilanie od cyfr dziewsiatek
        PORTB = liczby[dziesiatki]; //wyswietlanie tej cyfry
        _delay_ms(1);
        PORTC = _BV(CYFRA2); //zasilanie od cyfr jednosci
        PORTB = liczby[jednostki]; //wyswietlanie jej
        _delay_ms(1);
    }
}

void wyswietlanie2 (volatile uint8_t *odleglosc)
{
    int czas, jednostki, dziesiatki;
    int liczby[10] = {0x14, 0xD7, 0x8C, 0x85, 0x47, 0x25, 0x24, 0x97, 0x4, 0x5};
    jednostki=(*odleglosc%10); //obliczanie cyfry jednostki
    dziesiatki=(*odleglosc/10); //oblicznie cyfry dziesiatek
    for(czas=0; czas<czas_odswierzania; czas++)
    {
        PORTC = _BV(CYFRA3); // kolejne 2 ekraniki
        PORTB = liczby[dziesiatki]; //wyswietlanie tej cyfry
        _delay_ms(1);
        PORTC = _BV(CYFRA4); //zasilanie od cyfr jednosci
        PORTB = liczby[jednostki]; //wyswietlanie jej
        _delay_ms(1);
    }
}
int main()
{
    MCUCR |= (0<<ISC01)|(1<<ISC00); //ustawinie przerwan na interrupcie 0, PD2
    GICR |= (1<<INT0);

    TCCR0 = (0<<CS02)|(0<<CS01)|(1<<CS00); //brak preskalera na timerze0
    TIMSK = (1<<TOIE0); //wlaczenie zegarka 0

    DDRB = 0xff; //wyjkscie na wyswietlacz cyfry 8 ledowe
    PORTB = 0xff; //wylaczony na starcie
    DDRC = 0x1E; //zasilanie ekranu wyjscie

    DDRD |= _BV(TRIGGER1); //trigger jako wyjscie
    DDRD |= _BV(TRIGGER2);

    sei(); //wlaczenie przerwan globalnych

    volatile uint8_t lewy, prawy, error;

    while (1)
    {
        getdistance(&lewy, &prawy, &error);

        wyswietlanie1(&lewy);
        _delay_ms(2000);
    }
}
